<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>d3.js sandbox</title>
    <script src="d3.min.js"></script>
    <script src="../../../Others'/d3/d3.js"></script>
    <script src="fermata.min.js"></script>
    <script src="../../../&yet/fermata/fermata.js"></script>
    
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0">
    <style>
        html { height: 100%; }
        body { margin: 0px; background: black; height: 100%; }
        #nav {
            margin: 0px; height: 100px; width: 100%;
            overflow-x: auto; overflow-y: hidden; position: fixed;
            background-image: -webkit-linear-gradient(top, rgba(0,0,0,0.9) 25%, transparent);
        }
        #nav svg { display: block; }
        .dailyCount { stroke-width: 2.5; }
        #waterDrop { stroke: none; fill: blue; }
        
        #content { width: 100%; background-color: black; }
        #row_padding { float: left; height: 64px; margin: 16px 0px; }
        .frame { display: block; float: left; width: 64px; height: 64px; margin: 16px; }
        .photo { border: 2px solid white; }
    </style>
</head>
<body>
    <div id="nav"></div>
    <div id="top_padding"></div>
    <div id="content">
        <div id="row_padding"></div>
    </div>
    <div id="bot_padding"></div>
    
    <script>
        var overviewRows, overviewOffsets, activePhotos;
        
        var photoDB = fermata.json("http://localhost:5984")('photos');
        var photosIndexed = photoDB(['_design/shutterstem', '_view']);
        photosIndexed('by_date')({group_level:3}).get(function (e,d) {
            var runningTotal = 0;
            overviewRows = d.rows;
            overviewOffsets = overviewRows.map(function (row) {
                var offset = runningTotal;
                runningTotal += row.value;
                return offset;
            });
            updateOverview(d);
        });
        
        var updateDrop;
        function updateURL(startKey) {
            var query = {$startkey:startKey, limit:100, reduce:false};
            photosIndexed(['by_date'])(query).get(function (e,d) {
                updatePhotos(d);
            });
            
            //var url = fermata.raw({base:".", path:["d3_sandbox.html"], query:query})();
            //history.replaceState(null, null, url);
            history.replaceState(null, null, "?startkey=" + JSON.stringify(startKey));
            updateDrop(startKey);
        }
        
        var rowSeconds = function (r) {
            var a = r.key,
                d = new Date(a[0], a[1] - 1, a[2], a[3] || null, a[4] || null, a[5] || null);
            return d.getTime() / 1000;
        };
        var rowCount = function (r) {
            return r.value;
        };
        var rowSeason = function (r) {
            var seconds = rowSeconds(r),
                d = new Date(seconds * 1000),
                y0 = new Date(d.getFullYear(), 0, 1),
                y1 = new Date(d.getFullYear() + 1, 0, 1),
                θ = (d - y0) / (y1 - y0);
            return Math.cos(θ * 2 * Math.PI) / 2 + 0.5;
        };
        
        function updateOverview(d) {
            var W = 8000, H = 100;
            var scaleX = d3.scale.linear()
                .domain([d3.min(d.rows, rowSeconds), d3.max(d.rows, rowSeconds)])
                .range([15, W-15]);
            var scaleY = d3.scale.linear()
                 .domain([0, d3.max(d.rows, rowCount)])
                 .range([0, H]);
            var scaleSeason = d3.scale.linear()
                .range(['darkgoldenrod', 'lightsteelblue']);
            
            var timeline = d3.select('#nav').append('svg:svg').attr('width', W).attr('height', H);
            
            var dailyBars = timeline.selectAll('.dailyCount').data(d.rows);
            dailyBars.enter().append('svg:line').attr('class', "").classed('dailyCount', true) // (need .class to workaround weird iOS 4.2 selector issue)
                .attr('x1', function (r) { return scaleX(rowSeconds(r)); }).attr('x2', function (r) { return d3.select(this).attr('x1'); })
                .attr('y1', 0).attr('y2', function (r) { return scaleY(rowCount(r)); })
                .attr('stroke', function (r) { return scaleSeason(rowSeason(r)); });
            
            updateDrop = function (startKey) {
                var waterDrop = timeline.selectAll('#waterDrop').data([startKey])
                        .attr('cx', function (r) { return scaleX(rowSeconds({key:r})); });
                    waterDrop.enter().append('svg:circle').attr('id', "waterDrop")
                        .attr('cy', H  / 10).attr('r', 2.5)
                        .attr('cx', function (r) { return scaleX(rowSeconds({key:r})); });
            };
            
            timeline.on("click", function () {
                var seconds = scaleX.invert(d3.svg.mouse(this)[0]),
                    startDate = new Date(seconds*1000),
                    startKey = [startDate.getUTCFullYear(), startDate.getUTCMonth() + 1, startDate.getUTCDate()];
                updateURL(startKey);
            });
        }
        
        function updatePhotos(d) {
            var platen = d3.select('#content'),
                thumbs = platen.selectAll('.frame').data(d.rows, function (d) { return d.id; });
            
            thumbs.enter().append('div').classed('frame', true)
                .append('img').classed('photo', true).attr('src', function (d) { return photoDB([d.id, 'thumbnail/64.jpg'])(); });
            thumbs.exit().remove();
            
            // set up padding
            var Wp = 96, Hp = 96 - 16;
            var photosPerRow = Math.floor(platen.property('clientWidth') / Wp),
                topPadding = Hp * Math.floor(d.offset / photosPerRow),
                rowPadding = Wp * (d.offset - photosPerRow * topPadding / Hp),
                botPadding = Hp * Math.ceil((d.total_rows - d.rows.length - d.offset) / photosPerRow);
            d3.select("#top_padding").style('height', topPadding + "px");
            d3.select("#row_padding").style('width', rowPadding + "px");
            d3.select("#bot_padding").style('height', botPadding + "px");
            
            var autoscrolling, throttled;
            d3.select(window).on('scroll', function () {
                if (autoscrolling || !overviewOffsets) return;
                
                var newOffset = photosPerRow * Math.floor(this.scrollY / Hp),
                    overviewIndex = d3.bisectLeft(overviewOffsets, newOffset),
                    startKey = overviewRows[overviewIndex].key;
                
                clearTimeout(throttled);
                throttled = setTimeout(function () {
                    updateURL(startKey);
                }, 500);
            });
            
            thumbs = thumbs.sort(function (a, b) { return d3.ascending(rowSeconds(a), rowSeconds(b)); });
            autoscrolling = true;
            thumbs.node().scrollIntoView();
            setTimeout(function () {
                autoscrolling = false;
            }, 0);
        }
        
        // this initial set should eventually be done server-side
        photosIndexed(['by_date'])({reduce:false, limit:100}).get(function (e,d) {
            updatePhotos(d);
        });
    </script>
</body>
</html>
