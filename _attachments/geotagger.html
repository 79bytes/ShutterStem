<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>ShutterStem Geotagger</title>
    <script src="d3.min.js"></script>
    <script src="d3.geo.min.js"></script>
    <script src="fermata.min.js"></script>
    <script src="polymaps.min.js"></script>
    
    <!--
    <script src="../_attachments/d3.min.js"></script>
    <script src="../_attachments/d3.geo.min.js"></script>
    <script src="../_attachments/fermata.min.js"></script>
    <script src="../_attachments/polymaps.min.js"></script>
    -->
    
    <style>
        #map { width: 100%; height: 450px; }
        #timeline { width: 100%; height: 75px; border: 1px solid gray; }
        #thumbnails { width: 100%; margin: 5px 0; padding: 0; list-style: none; white-space: nowrap; overflow: auto; }
        #thumbnails li { display: inline; margin: 4px; }
        svg .photo { fill: gray; }
        svg .coord { fill: blue; }
        #seconds_slider { display: block; width: 100%; }
        #save_error { color: red; }
    </style>
</head>
<body>
    <ol id="thumbnails"></ol>
    <svg id="timeline"></svg>
    <div id="map"></div>
    <div id="controls">
        <input id="seconds_slider" type="range" min="-59" max="59" step="0.1" value="0" list="second_ticks">
        <datalist id="second_ticks"><option value="-30"><option value="0"><option value="30"></datalist>
        <label>Adjust timestamps:</label>
        <label><input id="hours_stepper" type="number" size="4" min="-12" max="12" value="0">h</label>
        <label><input id="minutes_stepper" type="number" size="4" min="-59" max="59" value="0">m</label>
        <label><input id="seconds_stepper" type="number" size="6" min="-59" max="59" step="0.1" value="0">s</label>
        <button id="save_button" type="button">Save</button><span id="save_error"></span>
    </div>
    
    <script id="setup" data-photo_db="http://localhost:5984/photos" data-location_db="http://localhost:5984/loctest" data-photo_rows="{{ photo_rows }}"></script>
    <script>
        // stub to facilitate quicker local iteration
        var req = new XMLHttpRequest();
        var server = (location.protocol.slice(0,4) == 'file') ? "http://localhost:5984" : '';
        req.open('GET', server + "/photos/_design/shutterstem-t3/_view/by_date?reduce=false&startkey=[2007,7,1]&limit=50", false);
        req.send();
        d3.select("#setup").attr('data-photo_db', server + "/photos");
        d3.select("#setup").attr('data-location_db', server + "/loctest");
        d3.select("#setup").attr('data-photo_query', req.response);
    </script>
    
    <script>
        var setupEl = d3.select("#setup"),
            photo_db = setupEl.attr('data-photo_db')
            location_db = setupEl.attr('data-location_db'),
            photo_query = JSON.parse(setupEl.attr('data-photo_query'));
        
        var adj_h = 0, adj_m = 0, adj_s = 0;
        function updateAdjustments() {
            d3.select('#hours_stepper').property('value', adj_h);
            d3.select('#minutes_stepper').property('value', adj_m);
            d3.select('#seconds_stepper').property('value', adj_s.toFixed(1));
            d3.select('#seconds_slider').property('value', adj_s);
        }
        updateAdjustments();
        
        var delayed_reload;
        d3.select('#hours_stepper').on('input', function () {
            adj_h = parseInt(this.value, 10) || 0;
            updateAdjustments();
            redrawPhotoMarkers();
            
            clearTimeout(delayed_reload);
            delayed_reload = setTimeout(function () {
                setTimeScale('redraw');
                reloadGeodata();
            }, 500);
        });
        d3.select('#minutes_stepper').on('input', function () {
            adj_m = parseInt(this.value, 10) || 0;
            updateAdjustments();
            redrawPhotoMarkers();
        });
        d3.select('#seconds_stepper').on('input', function () {
            adj_s = parseFloat(this.value) || 0;
            updateAdjustments();
            redrawPhotoMarkers();
        });
        d3.select('#seconds_slider').on('input', function () {
            adj_s = parseFloat(this.value) || 0;
            updateAdjustments();
            redrawPhotoMarkers();
        });
        
        var photoDB = fermata.json(photo_db),
            photos = photo_query.rows.map(function (r) { return {id:r.id, key:r.key, time:dateFromArrayUTC(r.key).getTime()}; });
        
        var thumbnails = d3.select("#thumbnails").selectAll('.photo').data(photos);
        thumbnails.enter().append('li').append('img').attr('src', function (d) { return photoDB(d.id)(["thumbnail/64.jpg"])(); });
        
        var timeline = d3.select("#timeline").attr('viewBox', "0 0 1000 100").attr('preserveAspectRatio', "none"),
            timelineAltitudesLayer = timeline.append('svg:g'),
            timelineMarkersLayer = timeline.append('svg:g');
        
        
        var minTime, maxTime, timeScaleX, timeScaleY = d3.scale.log().domain([500, 12500]).range([100, 0]);
        function setTimeScale(redraw) {
            var PADDING = 1.5, HOURS_TO_MSEC = 60 * 60 * 1000;
            minTime = photos[0].time + (adj_h - PADDING) * HOURS_TO_MSEC;
            maxTime = photos[photos.length - 1].time + (adj_h + PADDING) * HOURS_TO_MSEC;
            timeScaleX = d3.scale.linear().domain([minTime, maxTime]).range([0, 1000]);
            if (redraw) {
                if (coords) redrawGeodata();
                redrawPhotoMarkers();
            }
        }
        setTimeScale();
                
        
        var po = org.polymaps,
            map = po.map().container(d3.select('#map').append("svg:svg").node()),
            geodataLayer = po.geoJson().on('load', po.stylist().attr('r', 1).attr('class', "coord")),
            photoLayer = po.geoJson().on('load', po.stylist().attr('r', 3).attr('class', "photo"));
        //map.add(po.interact());
        map.add(po.image()
            .url(po.url("http://{S}tile.cloudmade.com"
            + "/51664f123b50414da85e963f92c721f0"
            + "/998/256/{Z}/{X}/{Y}.png")
            .hosts(["a.", "b.", "c.", ""])));
        map.add(geodataLayer);
        map.add(photoLayer);
        
        var coords, coordTimes;
        function redrawPhotoMarkers() {                 // also caches position on photos[n]._p
            var timeOffset = calculateTimeOffset(),
                timelineMarkers = timelineMarkersLayer.selectAll('.photo').data(photos);
            timelineMarkers.enter().append('svg:circle').classed('photo', true).attr('r', 3)
            timelineMarkers
                .attr('cx', function (d) { return timeScaleX(d.time + timeOffset); })
                .attr('cy', coords ? function (d) { d._p = positionForTime(d.time + timeOffset); return timeScaleY(d._p[2]+500); } : 50);
            timelineMarkers.exit().remove();
            
            if (coords) photoLayer.features(photos.map(function (d) {
                return {type: "Feature", properties: {id:d.id}, geometry: {type:"Point", coordinates:d._p} };
            }));
        }
        function redrawGeodata() {
            var timelineAltitudes = timelineAltitudesLayer.selectAll('.coord').data(coords);
            timelineAltitudes.enter().append('svg:circle').classed('coord', true).attr('r',1);
            timelineAltitudes.attr('cx', function (d) { return timeScaleX(d[3]); })
                .attr('cy', function (d) { return timeScaleY(d[2]+500); });
            timelineAltitudes.exit().remove()
            
            var coordFeatures = coords.map(function (d) { return {type:"Feature", properties:null, geometry:{type:"Point", coordinates:d}} }),
                b = d3.geo.bounds({type:"FeatureCollection", features:coordFeatures}).map(function (c) { return {lon:c[0], lat:c[1]}; });
            geodataLayer.features(coordFeatures);
            map.extent(b).zoomBy(-0.25);
        }
        function calculateTimeOffset() {
            return ((adj_h * 60 + adj_m) * 60 + adj_s) * 1000;
        }
        function positionForTime(t) {
            var i = d3.bisectLeft(coordTimes, t);
            i = Math.min(i, coordTimes.length - 1);
            return coords[i].map(function (c,i) { return (i === 3) ? t/1000 : c; });
        }
        redrawPhotoMarkers();
        
        var coordDB = fermata.json(location_db),
            coordsIndexed = coordDB(["_design/loclog", "_view"]);
        function reloadGeodata() {
            coordsIndexed('by_time', {reduce:false, $startkey:dateAsArrayUTC(minTime), $endkey:dateAsArrayUTC(maxTime)}).get(function (e,d) {
                coords = d.rows.map(function (r) { var c = r.value; c[3] = dateFromArrayUTC(r.key).getTime(); return c; }),
                    coordTimes = coords.map(function (c) { return c[3]; });
                redrawGeodata();
                redrawPhotoMarkers();
            });
        };
        reloadGeodata();
        
        function storePositions() {
            var positionsById = {},
                timeOffset = calculateTimeOffset();
            photos.forEach(function (d) {
                positionsById[d.id] = d._p;
            });
            photoDB('_all_docs', {include_docs:true}).post({keys:Object.keys(positionsById)}, function (e,d) {
                d3.select("#save_button").property('disabled', true);
                d3.select("#save_error").text(null);
                
                var updatedDocs = d.rows.map(function (row) {
                    var position = positionsById[row.id],
                        geotag = {'lat':position[1], 'lon':position[0], 'ele':position[2], 'time':position[3]};
                    row.doc.geotag = geotag;
                    return row.doc;
                });
                photoDB('_bulk_docs').post({all_or_nothing:true, docs:updatedDocs}, function (e,d) {
                    if (e) {
                        d3.select("#save_error").text(d.reason);
                    }
                    d3.select("#save_button").property('disabled', false);
                });
            });
        }
        d3.select("#save_button").on('click', function () {
            d3.event.preventDefault();
            storePositions();
        });
        
        function dateAsArrayUTC(date) {
            date instanceof Date || (date = new Date(date));
            return [
                date.getUTCFullYear(),      // 0
                date.getUTCMonth() + 1,     // 1
                date.getUTCDate(),          // 2
                date.getUTCHours(),         // 3
                date.getUTCMinutes(),       // 4
                date.getUTCSeconds() + (date.getUTCMilliseconds() / 1000)
            ];
        }
        function dateFromArrayUTC(arr) {
            var d = new Date();
            d.setUTCFullYear(arr[0] || 0);
            d.setUTCMonth(arr[1] - 1 || 0);
            d.setUTCDate(arr[2] || 1);
            d.setUTCHours(arr[3] || 0);
            d.setUTCMinutes(arr[4] || 0);
            d.setUTCSeconds(Math.floor(arr[5]) || 0);
            d.setUTCMilliseconds(1000 * (arr[5] - Math.floor(arr[5])) || 0);
            return d;
        }
    </script>
</body>
</html>
